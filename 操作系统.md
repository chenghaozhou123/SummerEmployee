# 进程管理

## 进程的状态

- 运行状态。一个进程在处理器上运行。
- 就绪状态。一个进程获得了除处理器外一切所需资源，一旦得到处理器，就可以运行。
- 等待状态。又称阻塞状态，一个进程正在等待某一事件发生而暂时停止运行。这时即使把处理器分配给该进程也无法运行。
- 新建状态。正在被创建，还没有转到就绪状态之前的状态。
- 结束状态。正在从系统中消失时的状态，由进程结束或者其他原因导致。

## 进程的挂起和解除挂起状态

为了更好的管理和调度进程及适应是同的功能，许多系统中都有“挂起”和“解除挂起”功能。

- 系统有时可能出故障或某些功能受到破坏
- 用户检查自己作业的中间执行情况和中间结果是，因同预期想法不符而产生怀疑，挂起进程，进行检查和改正
- 系统中有时符合过重，资源数相对不足，从而造成系统效率下降。此时需要挂起一部分进程以调整系统负荷，等系统中的负荷减轻后再将被挂起的进程恢复运行。

当进程再主存时，它就处于运行、就绪或者等待状态之一。但是，当进程处于等待状态时，进程所等待的事件并不能很快到来，所以进程再短时间内不能继续运行，所以它就没必要占着宝贵的主存空间。为了能使处于等待状态的进程释放主存空间，系统将其交换到辅存上，这时进程便处在挂起状态。

在支持虚拟存储管理的系统中，**进程的运行不要求将进程映像的所有程序和数据放入主存，只要求马上要运行的程序段和数据段在主存中。**反映映像位置的数据结构“页表”以及进程控制块的一些信息也需要占用物理内存。虽然说有要访问的程序或者数据都可以在要访问时才占用主存，但如果每个进程占用一点物理主存，当进程达到一定量时，主存也会显得不够用。就会出现每个进程都申请主存，系统已经没有空闲的主存，要求每个进程释放已经占用的主存的情形。这时系统性能也会有很大损失，会引起主辅内存频繁的交换，因为释放已占有主存要求将主存数据交换到辅存中，以备下次使用时将其调入主存，因此支持虚拟存储管理的系统中也需要进程交换功能。这时，处于挂起状态的进程意味着没有占用任何主存，unix中处于系统空间中的该进程页表以及部分进程控制块也交换到辅存，系统不会访问处于挂起状态的进程页表和那些交换出主存的进程控制块信息，知道进程被解卦。

挂起命令可以由进程自己或者其他进程发出，解除挂起命令只能由其他进程发出。

## 进程的描述和管理

操作系统用一个称为进程控制块PCB的数据结构来记录进程的属性信息。PCB一般包括三类信息：进程标识信息、处理器状态信息、进程控制信息。

1. 进程标识信息

   本进程的标识ID。通常用系统中唯一的数字作为标识，该数字实际是该进程的PCB在系统的PCB表中的表目序号。

   建立本进程的进程（父进程）的标识ID。

   用户标识

2. 处理器状态信息

   用户使用的寄存器

   控制和状态寄存器，包括程序计数器和条件寄存器

   堆栈指针

3. 进程控制信息

PCB不但是记录进程的属性信息，以便操作系统对其进行管理和控制。也标志着进程的存在，操作系统根据系统内是否由该进程控制块而知道该进程的存在与否。

## 进程管理

为了管理和调度，将各进程的PCB用适当的方法组织起来。

把所有不同状态的进程的PCB组织在一个表格中，这种方法最简单，适用于系统中进程数不多的类型，如UNIX。缺点是调度进程时，往往要查找整个PCB表。

把相同状态的进程的PCB放在同一个表格内。

分别把具有相同状态的所有进程的PCB按优先级拍成一个或多个队列（每个优先级一个）。这就分别形成了就绪队列，等待在不同事件上的各等待队列（等待队列一般不按优先级组织，通常按照其到达的先后次序排列）。如等待打印机的进程队列。采用队列形式时，每个进程的PCB中要增加一个链指针的表项，以指向下一个进程的PCB的起始地址。

# 操作系统的启动

启动：

从计算机原理来看，启动总共就三部分，分别是CPU，I/O和内存。

DISK（磁盘）：操作系统不是直接放在内存上可以直接执行，放在磁盘上。

BIOS：基本IO处理系统，按下电源开机之后，计算机系统可以开始检测外设，然后才能加载相应的软件执行。

bootloader:加载OS，将os从磁盘转移到内存中

BIOS：需要从特定地址开始执行，x86是在这个位置

![image-20220705171509866](C:\Users\ceho\AppData\Roaming\Typora\typora-user-images\image-20220705171509866.png)

一加电之后，就从这个位置开始执行。

bios如何把bootloader加载到内存上：

bootloader一般存放在硬盘的第一个主引导扇区，就把这一块加载到内存中去，这一个扇区一般是512字节。

然后bootloader

# 进程

进程的定义：

一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。

进程的组成：

程序的代码 代码需要放到内存中进行执行 ；

程序处理的数据；

程序计数器中的值，指示下一条将运行的指令；

 一组通用的寄存器的当前值，堆、栈；

一组系统资源（如打开的文件、网络等等）；

进程和程序的联系：

程序是产生进程的基础；

程序的每次执行构成了不同的进程，同时启动多个程序（多个微信），在内存中处理的数据可能不同，最后的结果导向就是不同的；

进程是程序功能的体现；

通过多次执行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序；

区别：

程序静态，进程动态。程序是有序代码的集合，进程是程序的执行，进程又用户态/内核态。（内核态，操作系统中运行。写代码并没有写操作系统的代码，进程在执行过程中需要完成特定的功能，比如读文件，这些需要操作系统来做，当进程发起读文件的请求，需要操作系统来执行，这个时候就处于内核态）

进程是暂时的，程序是永久的。进程是一个状态变化的过程，程序可长久保存。

组成不同：进程的组成包括程序、数据、和进程控制块（进程状态信息）。

进程的特点：

动态性：可动态的创建、结束进程

并发性：进程可以被独立调度并占用处理机运行。（一个cpu无法进行并行（现在的多核可以实现），每个进程占用一段时间片造成看似在同时运行的效果，叫并发）

独立性：不同进程的工作不相互影响

制约性：因访问数据/资源或进程间同步来产生制约

## PCB 

程序设计：程序=数据结构+算法

描述进程的数据结构：进程控制块（PCB）

PCB是进程存在的唯一标识，PCB存在进程存在。

PCB包含三类信息：

- 进程标识信息。如本进程的标识，父进程标识，用户标识。

- 处理机状态信息保存区。保存进程的运行现场信息。

- 进程控制信息

  调度和状态信息，用于操作系统调度进程并占用处理机使用

  进程间通信信息，为支持进程间的与通信相关的各种标识、信号、信件等，这些信息存在接收方的进程控制块中

  存储管理信息，包含有只想本进程映像存储空间的数据结构。

  进程所用资源，说明由进程打开、使用的系统资源。如打开的文件

  有关数据结构连接信息，进程可以连接到一个进程队列中，或连接到相关的其他进程的pcb

### pcb的组织方式

链表：同一状态的进程其pcb成一链表，多个状态对应多个不同的链表。

各状态的进程形成不同的链表：就绪链表、阻塞链表

索引表（数组）：同一状态的进程归汝一个index表，有index只想pcb，多个状态对应多个不同的index表

主要用链表，如果用数组的话，动态的插入删除开销会大一些 

如果一开始知道我的进程数量固定，不会有频繁的删除创建，采用数组也是一种比较快捷的方式。

# 进程管理

## 进程状态

进程的生命期管理：

之间记过笔记

# 线程管理

example:

<img src="C:\Users\ceho\AppData\Roaming\Typora\typora-user-images\image-20220706101607773.png" alt="image-20220706101607773" style="zoom:33%;" />

<img src="C:\Users\ceho\AppData\Roaming\Typora\typora-user-images\image-20220706101623319.png" alt="image-20220706101623319" style="zoom:33%;" />

问题：

<img src="C:\Users\ceho\AppData\Roaming\Typora\typora-user-images\image-20220706101848347.png" alt="image-20220706101848347" style="zoom:33%;" />

提出线程：

- 线程之间可以并发的执行

- 线程之间共享相同的地址空间和文件等资源

- 一个进程中可以同时存在多个线程

  缺点：一个线程崩溃，会导致其所属进程的所有线程崩溃，因为共享，当发生错误引起共享数据发生错误变化时就会这样。（浏览器过去采用线程方式，当有一个网页被注入恶意代码，会导致其他网页出现问题，但现在采用进程的方式）

线程是进程当中的一条执行流程。

两个方面理解进程：

资源组合的角度：进程把一组相关的资源组合起来，构成了一个资源平台，包括地址空间（代码段、数据段）、打开的文件等各种资源；

运行的角度：代码在这个资源平台上的一条执行流程（线程）

线程有自己的控制块TCB:

堆栈、PC寄存器等等，堆栈代码块资源块共享等等，也有不共享的部分

## 进程与线程比较

进程是资源分配单位，线程是cpu调度单位

进程拥有完整的资源平台，线程只独享必不可少的资源，如寄存器和栈（堆是共享的）

线程同样拥有就绪、阻塞、执行三种基本状态，同样就有三种状态的转化关系

### 线程能减少并发执行的时间和空间开销

线程创建时间比进程短（进程需要创建更多的管理信息，内存怎么去管理，打开的文件管理，线程只需要从用进程管理好的资源，创建时间短）

线程终止时间比进程短（线程不需要考虑那些东西的释放问题）

同一进程内的线程切换比进程短（线程具有同一地址空间，属于同一进程的线程具有相同的页表，切换的时候，线程不要切换这个东西。切换进程，还需要切换页表，cache信息，等等，看书，我记的书上有 ）

同一进程的各个线程间共享内存和文件资源，可直接进行不通过内核的通信。（由于线程共享了进程包含的资源，在做线程数据传递时，不需要通过内核，直接通过地址空间就能够访问到，使得线程间的数据交换效率很高。）

# 线程实现

用户线程：操作系统看不到，应用程序的库来进行实现，管理

内核线程：操作系统管理

用户线程与内核线程对应关系：

<img src="C:\Users\ceho\AppData\Roaming\Typora\typora-user-images\image-20220706105259832.png" alt="image-20220706105259832" style="zoom:25%;" />

<img src="C:\Users\ceho\AppData\Roaming\Typora\typora-user-images\image-20220706105323598.png" alt="image-20220706105323598" style="zoom:25%;" />

<img src="C:\Users\ceho\AppData\Roaming\Typora\typora-user-images\image-20220706105335431.png" alt="image-20220706105335431" style="zoom:25%;" />

一对一，一对多，m对n

**操作系统看得到进程以及其拥有的相关资源，但是进程里的线程信息由线程管理库来实现的，操作系统看不到，线程管理和调度，由库完成，库中可以自定义线程调度算法。**

<img src="C:\Users\ceho\AppData\Roaming\Typora\typora-user-images\image-20220706105653477.png" alt="image-20220706105653477" style="zoom:50%;" />

用户线程缺点： 

内核线程：

<img src="C:\Users\ceho\AppData\Roaming\Typora\typora-user-images\image-20220706110629213.png" alt="image-20220706110629213" style="zoom:50%;" />

第一点：TCB组成一个LIST，由PCB来管理。属于这个进程的所有线程都被PCB统一管理。具体调度的时候是由TCB来完成。 

轻量级进程：

内核支持的用户线程。一个进程可以有一个或多个轻量级进程，每个量级进程由一个单独的内核线程来支持。 

优先级反转的问题中，为什么高优先级一个抢占一个等待

# 进程的通信方式

- 匿名管道

  两个进程间打开的文件，一个进程写入一个进程读出，系统负责彼此间的同步执行。

  无名管道用于密切相关的父子进程或兄弟进程之间的通信。

  ```shell
  ps -ef|grep python
  ```

  进程创建pipe文件，通常就创建一个或几个子进程，于是子进程复制父进程的用户打开文件表，这样pipe文件就为父子间共享。进程使用无名管道时，想普通文件一样读写，使用完后调用close命令关闭管道文件。无名管道只是一个临时文件，关闭后文件就不复存在了。

- 命名管道

  用于一般的无家族关系的进程间的通信。有名管道这种文件有对应的文件目录项，这种文件不显式删除就永久存在。发送者以只写、接受者以只读方式打开。

  进程使用有名管道实现通信需要有三次同步。打开同步（读打开时发现写者打开过，就唤醒写。反之亦然。没唤醒，则等待），读写同步（允许写者超前1024个字节写入，当要写更多时，写需等待。读时无数据则等待，有数据读完后检查有无写者等待，有则唤醒。而且通信双方检查通信另一方是否存在，一旦一方不存在就终止通信），关闭同步（写关闭管道，发现有读者睡眠等待，唤醒它并向他发送一个指示错误条件的信号后返回，最后一个关闭管道的进程释放盘块及在主存中相应i节点）。

- 信号（软中断）

  进程可以发送少量信息并进行适当处理。**同组进程之间可以互相发送信号，内核也可以从内部发信号给进程。将信号放到目标进程的信号队列中，如果目标进程未处于执行状态，该信号先被保存，直到该进程恢复执行状态并将信号传递给他。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程**系统提供了19个软中断信号，0~19，0是没有软中断发生，超过19的软中断号，系统不予理睬。接收进程收到软中断信号后，并不能立即响应，有可能进程不在主存，而是等到接收进程运行或者从系统调用返回用户空间时。

  一个进程可能收到多个不同类型的软中断。内核允许每次只处理一个软中断信号。较小的被优先处理，其它的软中断只有在进程下次被调度时才可能被处理。

  

- 信号量

  一个信号量被定义为一个整型变量，在其上定义了以下三个操作：

  1. 可以被初始化为一个非负数。
  2. wait操作，将信号量值减1后，若该值为负，则执行wait操作的进程等待。
  3. signal操作，将信号值增1后，若该值为为非正，则执行signal操作的进程唤醒等待进程（唤醒动作只用于阻塞等待情况）。

  按用途分为二元信号量（取值为0和1，主要用作互斥变量）和一般信号量，它允许取值为非负整数，主要用于进程间的一般同步问题。

- 消息队列

  所用数据结构

  1）消息缓冲区

  结构定义如下：

  ```c
  struct msgbuf{
  long mtype;  // 消息类型，可以是正负0
  char mtext[N];  // 消息正文
  };		
  ```

  2）消息头结构和消息头表

  - 消息头结构

  对应每一个消息缓冲区都有一个消息头结构，结构如下：

  ```C
  struct msg{
  	msg-next;  // 消息队列中指向下一个消息的指针
  	long msg-type;  // 消息类型（与消息缓冲区的相同）
  	short msg-ts;  // 消息正文长度
  	short msg-spot;  // 消息正文地址
  }
  ```

  - 消息头结构表

    由若干个消息头结构构成的数组。

  3）消息队列头结构和消息队列头表

  由于可以有多个消息队列，对应每个消息队列都有一个消息队列头结构

  4）消息缓冲池

  系统对消息正文的管理是将所有消息正文放在消息缓冲池中。消息缓冲池的结构包括缓冲池的大小和首地址两项信息。

- 共享内存

  通信进程直接访问某些共享的虚拟存储空间而实现通信。操作系统管理一组共享主存控制块。通信进程在使用共享主存段以前先提出申请，系统分配给它并返回一个共享主存段标识号。一个共享主存建立后被附加到进程的虚拟空间地址，进程可以附加多个共享主存段。

  使用的数据结构：

  1.共享主存段控制块，包含以下信息：

  共享主存段访问控制结构

  共享段长度

  共享段页表始址

  最后执行该共享段操作的进程ID

  创建该共享段的进程ID

  当前附加段号和主存中的附加段号

  最近一次附加操作、拆卸操作和修改时间

  2.共享主存段的数据结构

  每个共享主存段都对应有一个页表和允许的存取权限。每个进程最多允许6个共享主存段，每个共享主存段有自己的页表。

- 套接字

  主要用于多机之间的进程通信
  
  独占资源(这个和在GitHub看的不一样，具体需要查找书上来进一步判断)
1、线程ID
同一进程中每个线程拥有唯一的线程ID。
2、寄存器组的值
由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线 程切换到另一个线程上 时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。
3、线程堆栈
线程可以进行函数调用，必然会使用大函数堆栈。
4、错误返回码
线程执行出错时，必须明确是哪个线程出现何种错误，因此不同的线程应该拥有自己的错误返回码变量。
5、信号屏蔽码
由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器。
6、线程的优先级
由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。
