#### 1.进程什么时候在内存中？

进程都是在内存中运行的。或者准确来讲你说的进程的五个状态都是在内存的。从创建开始，进程就处在了内存中，直到消亡（结束）。但是进程还有一个状态叫挂起，挂起态分为阻塞挂起和就绪挂起。在挂起状态下，进程是在外存的。

#### 2.进程创建的时候是要创建虚拟内存、页和页表映射的表，然后将数据存放在虚拟内存中再加载到物理内存中来吗？

在32位的操作系统中，当进程创建的时候（程序运行时），系统会为每一个进程分配大小为4GB的虚拟内存空间，用于存储进程属性信息。

#### 3.应用程序在用户态下可以执行程序吗？

可以。

cpu有四种状态，分别为编号0到3，以及三个受保护的对象：内存，i/o端口和执行某些机器指令的能力。

操作系统基于cpu之上，用到两种状态分别为内核态和用户态。

**首先内核态与用户态是操作系统的两种运行级别**

用户运行一个程序，该程序创建的进程开始是运行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过send,write等系统调用，就会调用内核的代码来完成操作这时，必须切换到Ring0，然后进入`内核地址空间`去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。

#### 用户态如何进入内核态执行代码？

**系统调用**
这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如x86里的call gate也可以用来做系统调用，也能做到权限控制和内核代码保护，跟中断的效果完全一样。

**硬中断**

当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。该中断可被屏蔽。
从本质上讲，中断(硬)是一种电信号，当设备有某种事情发生的时候，他就会产生中断，通过总线把电信号发送给中断控制器。如果中断的线是激活的(与逻辑门的另外一边设置的是高电平，如果是低电平就进行了屏蔽)，中断控制器就把电信号发送给处理器的某个特定引脚。处理器于是立即停止自己正在做的事，跳到中断处理程序的入口点，进行中断处理。

**软中断(softIRQ)**

信号是软中断？（回去看下操作系统的书，记得有讲）

软中断(softIRQ)的一种典型应用就是所谓的"下半部"（bottom half），它的得名来自于将硬件中断处理分离成"上半部"和"下半部"两个阶段的机制：上半部在屏蔽中断的上下文中运行，用于完成关键性的处理动作；而下半部则相对来说并不是非常紧急的，通常还是比较耗时的，因此由系统自行安排运行时机，不在中断服务上下文中执行。
在系统调用的时候，也可以用软中断的方式实现，比如 fork() 实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如 Linux 的 int 80h 中断。该中断不可被屏蔽。

**异常**
当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

首先明确下什么是缺页异常，CPU通过地址总线可以访问连接在地址总线上的所有外设，包括物理内存、IO设备等等，但从CPU发出的访问地址并非是这些外设在地址总线上的物理地址，而是一个虚拟地址，由MMU将虚拟地址转换成物理地址再从地址总线上发出，MMU上的这种虚拟地址和物理地址的转换关系是需要创建的，并且MMU还可以设置这个物理页是否可以进行写操作，当没有创建一个虚拟地址到物理地址的映射，或者创建了这样的映射，但那个物理页不可写的时候，MMU将会通知CPU产生了一个缺页异常。
下面总结下缺页异常的几种情况：
1、当MMU中确实没有创建虚拟页物理页映射关系，并且在该虚拟地址之后再没有当前进程的线性区vma的时候，可以肯定这是一个编码错误，这将杀掉该进程；
2、当MMU中确实没有创建虚拟页物理页映射关系，并且在该虚拟地址之后存在当前进程的线性区vma的时候，这很可能是缺页异常，并且可能是栈溢出导致的缺页异常；
3、当使用malloc/mmap等希望访问物理空间的库函数/系统调用后，由于linux并未真正给新创建的vma映射物理页，此时若先进行写操作，将如上面的2的情况产生缺页异常，若先进行读操作虽也会产生缺页异常，将被映射给默认的零页(zero_pfn)，等再进行写操作时，仍会产生缺页异常，这次必须分配物理页了，进入写时复制的流程；
4、当使用fork等系统调用创建子进程时，子进程不论有无自己的vma，“它的”vma都有对于物理页的映射，但它们共同映射的这些物理页属性为只读，即linux并未给子进程真正分配物理页，当父子进程任何一方要写相应物理页时，导致缺页异常的写时复制。

#### 系统调用的执行过程

1、硬件接收到中断信号（接收到系统调用信号），立刻保存现场，并查找中断向量表，将CPU控制权转交给系统调用总入口程序。
2、对于系统调用总入口程序，也要先保存现场，将参数保存在内核的堆栈中。然后查找系统调用表，将CPU控制权转交给对应的系统调用处理程序或者是内核函数。
3、执行系统调用处理程序
4、恢复现场，返回用户程序。

#### 中断异常

#### 一直敲键盘频繁引起中断？

<img src="https://img-blog.csdnimg.cn/20210420185920388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjY0NTYxMw==,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom: 80%;" />

#### 线程有自己的堆空间吗？

与线程“绑定”的是栈，用于存储自动变量。每一个线程建立的时候，都会新建一个默认栈与之配合。堆则是通常与进程相关，用于存储全局性的变量，进程建立的时候，会建立默认堆。于是，每一个线程都有自己的栈，然后访问共同的堆。当然，你可以通过OsApi建立其他堆栈。

```
堆：是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。
栈：是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread safe的。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放。
```

#### 进程的虚拟内存地址分布

![img](https://img-blog.csdnimg.cn/ccbed52609774b53a07dccc0d7f255fe.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVmFpbjk1Nw==,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 进程切换时页表的切换，由于进程之间共享内核空间，那么页表切换的时候这部分是不是不用动

而且，由于操作系统内核的页表是固定的，所以一个4G的地址空间，只有2-3G的页表是会变化的，其余的部分划分给内核，进程切换不会导致内核页表变化。