# go环境搭建

$HOME/.profile的环境是对当前用户生效

/etc/profile是对当前用户生效

选择一个：

export GOROOT=/usr/local/go

export PATH=$PATH:$GOROOT/bin

go什么情况下会创建一个线程。

Go协程被多路复用到较少的OS线程。在一个程序中数千个Go协程可能只运行在一个线程中。如果该线程中的任何一个Go协程阻塞（比如等待用户输入），那么Go会创建一个新的OS线程并将其余的Go协程移动到这个新的OS线程。所有这些操作都是 runtime 来完成的，而我们程序员不必关心这些复杂的细节，只需要利用 Go 提供的简洁的 API 来处理并发就可以了。

# go是静态类型语言

什么叫动态类型语言？

动态类型语言是指在运行期间才去做数据类型检查的语言。也就是说，在用动态类型的语言编程时，永远不用给任何变量指定数据类型，该语言会在你第一次赋值给变量的时候，在内部将数据类型记录下来。类型对于变量，属性，方法以及方法的返回类型都是可有可无的，在给变量赋值时才决定它的类型， 之后，还可以赋值不同类型的值，即使是基本类型，比如 C# 装箱（boxing）和拆箱（unboxing），可以把值类型转换成引用类型，引用类型转换成值类型。当需要时，很多类型之间都会发生自动转换，可以把不同的基本类型添加到同一数组（collections）中。
什么叫静态语言类型？

静态类型语言与动态类型语言刚好相反，它的数据类型是在编译期间检查的。也就是说，在编写程序的时候就要声明所有变量的数据类型。C/C++是静态类型语言的典型带便，其它的静态类型语言还有C#、Java等



# kratos

微服务框架，以http/grpc为基础，通过protobuf进行定义。



# 消息队列作用

**流量控制，削峰**

我们的应用处理请求能力是有限，在一些存在海量请求的场景中，比如秒杀、抢购等等。如果直接处理这海量请求，可能我们的应用早挂掉了。这时候可以把这些请求丢进消息队列中，下游系统以自己的处理能力消费这些消息，起到了削峰填谷的作用。

**异步处理**

举个例子：在商城系统中，订单系统下单成功后，需要一些后处理，比如扣减库存、统计销售数量、短信通知、消息推送、优惠卷占用等等。如果所有这些操作都是同步处理，那下单耗时非常严重，影响用户体验。可以利用消息队列将这些同步操作改为向各个系统发送消息，接口直接返回订单信息。

**应用间解耦**

下游应用依赖上层应用，这种耦合关系会带来很多弊端。

在商城购买商品，通过订单系统生成订单，而发货系统则根据订单来发货；按照这个逻辑，当订单系统发生故障时，发货系统也会出现问题。怎样解决这个问题，那就是解耦，使两个系统分离。

1）构建订单系统，将订单系统产生的订单已记录的形式存储在数据库中（也可使用缓存）

2）构建发货系统，从数据库中读取订单，进行处理

# gin

路由算法



# 数据结构

应该分点讲

## channel

13. ```
    type hchan struct {
    uint
    // 当前队列中剩余元素个数
    2.qcount3.dataqsiz uint4.buf5.elemsize uint166.closed7.elemtype *_type// 元素类型
    8.sendxuint// 队列下标，指示元素写入时存放到队列中的位置
    // 环形队列长度，即可以存放的元素个数
    unsafe.Pointer // 环形队列指针
    uint32
    // 每个元素的大小
    // 标识关闭状态
    9.recvxuint// 队列下标，指示元素从队列的该位置读出
    10.recvqwaitq// 等待读消息的goroutine队列
    11.sendqwaitq// 等待写消息的goroutine队列
    12.lock mutex
    // 互斥锁，chan不允许并发读写
    
    }
    ```

    

### 环形队列

channel内部实现了一个环形队列作为缓冲区，其中channel数据结构中的buf指向了队列起始地址，sendx队列下，表示从该位置写入，recvx表示从该队列位置读出。

### 等待队列

recvq

### 发送队列

sendq

### 互斥锁

不允许并发读写

## Slice

```
1. type slice struct {
2.array unsafe.Pointer
3.len int
4.cap int
5. }
```

### 创建方式

```
make([]int, 5, 10)
使用数组创建：
array ：= [10]int
array[5:7]
```

### 扩容

append进行追加时

空间不足会进行扩容，扩容先按扩容策略开辟一个新的地址空间然后将旧数据复制进去，再追加新数据

策略：小于1024就内存加倍，大于等于1024就扩1.25倍

**注意有一题很好，就是传参的时候，由于数据结构的问题，里面的指针最开始都是指向同一地址空间**

slice copy的时候都是取最小的进行copy

### 特殊切片

array[5:7:7]表示取5-7，然后切片的cap是第三个参数减第一个参数

## Map

```
1. type hmap struct {
2.count
3....
4.B
5....
6.buckets
7....
int // 当前保存的元素个数
uint8
// 指示bucket数组的大小
unsafe.Pointer // bucket数组指针，数组的大小为2^B
8. }
```

参数中有个B表示bucket的数量，2的B次方

### bucket

```
1. type bmap struct {
2.tophash [8]uint8 //存储哈希值的高8位
3.data
4.overflow *bmap
byte[1]
//key value数据:key/key/key/.../value/value/value...
//溢出bucket的地址
5. }
```

每个bucket可以存储8个键值对

tophash：低八位相同的hash值被存到这里，然后高8位存到这个数据中

data：存放数据 key/value

overflow:一个指针，当满了的时候指向下一个bucket

### 哈希冲突

低八位相同，然后到了一个bucket就是哈希冲突了

### 负载因子

键数量 / bucket数量

哈希因子过小，说明空间利用率低
哈希因子过大，说明冲突严重，存取效率低

每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载因子达到6.5时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，
所以Go可以容忍更高的负载因子。

### 渐进式扩容

#### 增量扩容

大于负载因子的时候或者overflow>32768的时候，需要扩容，慢慢的扩，不是一次性迁移数据，当有读写时就迁移几个，bucket指向扩容后的，oldbucket指向扩容前的。

#### 等量扩容

当进行大量增删后，就会出现负载不均衡的现象，需要等量扩容，方式与增量扩容类似

## struct

## iota

## string

## defer

规则一：延迟函数的参数在defer语句出现时就已经确认了

规则二：延迟函数执行按后进先出顺序执行

规则三：延时函数可能操作主函数的具名返回值

### 数据结构

```
1. type _defer struct {
2.sp uintptr//函数栈指针
3.pc uintptr//程序计数器
4.fn *funcval//函数地址
5.link *_defer//指向自身结构的指针，用于链接多个defer
6. }
```

